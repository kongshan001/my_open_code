import { BaseAgent } from '../agent-base.js';
import { AgentConfig, AgentExecutionResult } from '../agent-types.js';
import { Task } from '../web-types.js';
import { executeTool } from '../tool.js';

export class ProductAgent extends BaseAgent {
  constructor(config: Partial<AgentConfig> = {}) {
    const defaultConfig: AgentConfig = {
      id: config.id || 'agent-product-1',
      name: config.name || 'Product Manager Agent',
      role: 'product',
      description: 'Specialized in product management, requirements analysis, and documentation',
      systemPrompt: `You are an expert product manager. Your role is to:
1. Analyze user requirements and create specifications
2. Write product documentation and user stories
3. Create and maintain project roadmaps
4. Prioritize features and tasks
5. Conduct market research and competitive analysis
6. Create acceptance criteria and test scenarios`,
      tools: ['read', 'write', 'bash', 'analysis'],
      capabilities: [
        { id: 'req-analysis', name: 'Requirements Analysis', description: 'Analyze and document requirements', enabled: true },
        { id: 'doc-writing', name: 'Documentation', description: 'Write product documentation', enabled: true },
        { id: 'roadmap', name: 'Roadmap Planning', description: 'Create project roadmaps', enabled: true },
        { id: 'user-stories', name: 'User Stories', description: 'Create user stories', enabled: true },
        { id: 'acceptance', name: 'Acceptance Criteria', description: 'Define acceptance criteria', enabled: true },
      ],
      priority: config.priority || 'medium',
      maxConcurrentTasks: config.maxConcurrentTasks || 2,
      timeout: config.timeout || 45000,
    };
    
    super({ ...defaultConfig, ...config } as AgentConfig);
  }

  async execute(task: Task): Promise<AgentExecutionResult> {
    const startTime = Date.now();
    this.updateStatus('busy');

    try {
      console.log(`[${this.name}] Processing task: ${task.name}`);

      let output = '';

      switch (task.type) {
        case 'file':
          output = await this.handleDocumentation(task);
          break;
        case 'custom':
          output = await this.handleProductTask(task);
          break;
        case 'api':
          output = await this.handleMarketResearch(task);
          break;
        default:
          throw new Error(`Unsupported task type for product: ${task.type}`);
      }

      const result = this.createExecutionResult(true, output, startTime);
      return result;
    } catch (error: any) {
      const result = this.createExecutionResult(false, '', startTime, error.message);
      return result;
    }
  }

  private async handleDocumentation(task: Task): Promise<string> {
    const fileConfig = task.config.file;
    if (!fileConfig) {
      throw new Error('File configuration is missing');
    }

    const context = this.getToolContext(task);

    switch (fileConfig.operation) {
      case 'read':
        const readResult = await executeTool('read', {
          file_path: fileConfig.path,
          offset: 0,
          limit: 2000,
        }, context);
        return readResult.output;

      case 'write':
        const documentation = this.generateDocumentation(task);
        const writeResult = await executeTool('bash', {
          command: `cat > "${fileConfig.path}" << 'EOF'\n${documentation}\nEOF`,
        }, context);
        return writeResult.output;

      default:
        throw new Error(`File operation ${fileConfig.operation} not implemented for product agent`);
    }
  }

  private generateDocumentation(task: Task): string {
    const timestamp = new Date().toISOString();
    
    return `
# ${task.name}

## Description
${task.description}

## Requirements
- ${task.metadata?.requirements || 'To be defined'}

## User Stories
- As a user, I want ${task.metadata?.userStory || 'basic functionality'} so that I can achieve my goals.

## Acceptance Criteria
- [ ] Feature works as expected
- [ ] All edge cases are handled
- [ ] Performance meets requirements
- [ ] Documentation is complete

## Tasks
${task.metadata?.tasks ? task.metadata.tasks.map((t: string, i: number) => `- [ ] ${t}`).join('\n') : '- [ ] Define initial tasks'}

## Notes
${task.metadata?.notes || 'Additional notes to be added'}

---
*Generated by ${this.name} on ${timestamp}*
    `.trim();
  }

  private async handleProductTask(task: Task): Promise<string> {
    const customConfig = task.config.custom;
    if (!customConfig) {
      throw new Error('Custom configuration is missing');
    }

    const taskType = customConfig.taskType || 'general';

    switch (taskType) {
      case 'user-story':
        return this.createUserStory(customConfig);
      case 'acceptance-criteria':
        return this.createAcceptanceCriteria(customConfig);
      case 'roadmap':
        return this.createRoadmap(customConfig);
      default:
        return this.handleGeneralProductTask(customConfig);
    }
  }

  private createUserStory(config: any): string {
    return `
## User Story

**Title**: ${config.title || 'New Feature'}

**As a** ${config.role || 'user'},
**I want** ${config.want || 'to perform an action'},
**So that** ${config.benefit || 'I can achieve a goal'}.

**Priority**: ${config.priority || 'Medium'}
**Complexity**: ${config.complexity || 'Medium'}

**Acceptance Criteria**:
${config.criteria || '- [ ] Functional requirements met'}

**Dependencies**:
${config.dependencies || '- None'}

**Notes**:
${config.notes || 'None'}
    `.trim();
  }

  private createAcceptanceCriteria(config: any): string {
    return `
## Acceptance Criteria

**Feature**: ${config.feature || 'Feature Name'}

**Given** ${config.given || 'preconditions'},
**When** ${config.when || 'action occurs'},
**Then** ${config.then || 'expected outcome'}.

**Test Scenarios**:
${config.scenarios ? config.scenarios.map((s: string, i: number) => `
${i + 1}. ${s}
   - Expected: ${config.expectedResults?.[i] || 'Pass'}
`).join('\n') : '1. Scenario 1\n   - Expected: Pass'}

**Edge Cases**:
${config.edgeCases || '- [ ] Test with invalid input\n- [ ] Test with empty input'}

**Performance Requirements**:
- Response time < ${config.maxResponseTime || '2s'}
- Throughput > ${config.minThroughput || '100 req/s'}
    `.trim();
  }

  private createRoadmap(config: any): string {
    return `
## Product Roadmap

**Version**: ${config.version || '1.0.0'}
**Timeline**: ${config.timeline || 'Q1 2024'}

### Phase 1: Foundation (${config.phase1?.duration || '4 weeks'})
${config.phase1?.items?.map((item: string) => `- ${item}`).join('\n') || '- Setup project structure\n- Core features'}

### Phase 2: Development (${config.phase2?.duration || '6 weeks'})
${config.phase2?.items?.map((item: string) => `- ${item}`).join('\n') || '- Feature development\n- Integration'}

### Phase 3: Testing & Launch (${config.phase3?.duration || '3 weeks'})
${config.phase3?.items?.map((item: string) => `- ${item}`).join('\n') || '- Testing\n- Deployment'}

### Milestones
${config.milestones ? config.milestones.map((m: any, i: number) => `
**Milestone ${i + 1}**: ${m.name} (${m.date})
- ${m.description}
`).join('\n') : `
**Milestone 1**: Alpha Release (Week 4)
- Core features complete

**Milestone 2**: Beta Release (Week 10)
- All features complete

**Milestone 3**: GA Release (Week 13)
- Product launch
`}

**Risks & Dependencies**:
${config.risks ? config.risks.map((r: string) => `- ${r}`).join('\n') : '- Team availability\n- Third-party integrations'}
    `.trim();
  }

  private async handleMarketResearch(task: Task): Promise<string> {
    const apiConfig = task.config.api;
    if (!apiConfig) {
      throw new Error('API configuration is missing');
    }

    const response = await fetch(apiConfig.url, {
      method: apiConfig.method,
      headers: apiConfig.headers,
      body: apiConfig.body ? JSON.stringify(apiConfig.body) : undefined,
    });

    const text = await response.text();

    const summary = `
## Market Research Summary

**Source**: ${apiConfig.url}
**Data Retrieved**: ${new Date().toISOString()}
**Status**: ${response.status}

**Key Insights**:
- Data successfully retrieved
- Ready for analysis

**Raw Data**:
${text.substring(0, 1000)}${text.length > 1000 ? '...' : ''}
    `.trim();

    return summary;
  }

  private handleGeneralProductTask(config: any): string {
    return `
## Product Task Result

**Task Type**: ${config.taskType || 'General'}
**Status**: Completed

**Output**:
${JSON.stringify(config.result || {}, null, 2)}

**Recommendations**:
- Review the output above
- Apply relevant findings to product decisions
- Consider stakeholder feedback
    `.trim();
  }
}